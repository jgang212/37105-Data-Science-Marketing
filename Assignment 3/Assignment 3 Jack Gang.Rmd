---
title: "Private Label Demand"
author: "Jack Gang"
date: "1/31/2017"
output:
  html_document:
    df_print: paged
  pdf_document: default
  word_document: default
header-includes: \usepackage{color}
graphics: yes
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, comment = NA, message = FALSE,
                      fig.width = 10, fig.height = 10, fig.align = "center")
```

In this assignment, we will answer the question of whether private label demand is sensitive to household income and wealth. We will study this question using data from the Nielsen Homescan panel, and we will also use publicly available local home value data from Zillow as a measure of wealth. The overall data analysis strategy is as follows:

1. Construct household-level private label shares for all months between 2004-2014
2. Use household-level income, employment, and other information contained in the Nielsen data
3. Use local, 5-digit ZIP code Zillow home value data as a measure of local housing wealth
4. Summarize the data
5. Provide regression results of private label shares on income, employment, wealth (Zillow home value index), and other controls

In the first part of the assignment we will construct the private label share data and save them to file. In the second part we will finish the data preparation and then run the statistical analysis.

## Zillow data construction

We first retrieved the Zillow data (in csv format) from the Zillow website:


```{r}
library(bit64)
library(data.table)
library(lubridate)

# read in Zillow data
zillow_DT = fread("http://files.zillowstatic.com/research/public/Zip/Zip_Zhvi_AllHomes.csv")
names(zillow_DT)[1:20]
```

Next, we `melt`ed the table from wide to long format:

```{r}
# melt zillow_DT
zillow_DT = melt(zillow_DT, id.vars = names(zillow_DT)[1:7], measure.vars = 
                   names(zillow_DT)[8:ncol(zillow_DT)], variable.name = "date",
                 value.name = "zillow_index")
head(zillow_DT)
```

Before saving the data, we wanted to clean it. First, we converted `date` to a `month_year` R date variable:

```{r}
# convert date to month_year
zillow_DT[, date := as.character(date)]
zillow_DT[, month_year := ymd(date, truncated = 2)]
```

We then created a `zip_code` variable from `RegionName`:

```{r}
zillow_DT[, zip_code := as.integer(RegionName)]
```

Finally, we removed some unnecessary variables, set the preferred column order, and keyed the data:

```{r}
zillow_DT[, c("date", "RegionID", "RegionName") := NULL]
setcolorder(zillow_DT, c("zip_code", "month_year", "zillow_index","City",
                         "State", "Metro", "CountyName", "SizeRank"))
setkey(zillow_DT, zip_code, month_year)
```

After cleaning the data, we saved it to a file:

```{r}
save(zillow_DT, file = "/classes/37105/group7/Assignment 3/Data/Zillow-Data.RData")
```

## Household-level private label share creation

### Tagging private label products

We used the same Nielsen Homescan household panel data for the analysis as we did in the first assignment. The first thing we did was analyze the evolution of private label shares. We loaded the product data and added a flag called `is_PL` that equals `TRUE` if a product is a private label product:

```{r}
# load the product data
load("/classes/37105/main/Assignment-3/Products.RData")

# add a flag to mark if a product is a private label
products[, is_PL := ifelse(like(brand_descr, "CTL BR"), TRUE, FALSE)]

# look at table of all the matches for private label
table(products[products$is_PL]$brand_descr)
```

### Iteration and data reduction strategy

Since the purchase data are at the year level, we iterated over all the files to combine the calculations in one table. For each household, we calculated private label shares at the year/month level:

```{r}
shares_DT = data.table()

# iterate over all purchase files
for (yr in 2004:2014)
{
  # load purchase data
  load(paste0("/classes/37105/main/Assignment-3/purchases_", yr, ".RData"))
  
  # merge is_PL flag, department code, and product module code
  purchases = merge(purchases, 
                    products[, .(upc, upc_ver_uc, is_PL, department_code, 
                                 product_module_code)])
  
  # drop some departments and product modules from the data set
  department_DT = products[, head(.SD, 1), by = department_code,
                     .SDcols = c("department_descr")]
  department_DT[order(department_code)]
  
  purchases = purchases[purchases$department_code != 9] # general merchandise
  purchases = purchases[purchases$department_code != 99] # magnet data
  purchases = purchases[purchases$product_module_code >= 1000] # magnet data 
  purchases = purchases[!is.na(purchases$department_code)] # unknown department code
  
  # create a month_year date variable
  purchases[, month_year := floor_date(purchases$purchase_date, "month")]
  
  # create total dollar spending at the household/month/year level, separately 
  # for private label and other (national brand) products
  purchases[, no_households := length(unique(household_code)), by = month_year]
  purchases_total = purchases[, .(totalSpend = sum(total_price_paid - coupon_value)),
                           keyby = .(is_PL, household_code, month_year)]
  purchases_total = dcast(purchases_total, household_code + month_year ~ is_PL, 
               value.var = c("totalSpend"))
  
  # convert to percentage shares
  purchases_total[, perc_share := purchases_total$"TRUE"/
                    (purchases_total$"TRUE" + purchases_total$"FALSE")]
  
  # keep data on household/month/year/private label shares only
  purchases_total[, c("TRUE","FALSE"):=NULL]
  
  # insert the final data for the given year into a list
  shares_DT = rbind(shares_DT, purchases_total)
}

# remove missing values due to 0 household spending
nrow(shares_DT)
shares_DT = shares_DT[complete.cases(shares_DT)]
nrow(shares_DT)

# key the data at the household/month/year level save to file
setkeyv(shares_DT, c("household_code", "month_year"))
save(shares_DT, file = "/classes/37105/group7/Assignment 3/Data/shares-Data.RData")

```

## Household data preparation

Before we began with the main analysis, we first examined the household data in the `panelists.RData` file.

```{r}
library(psych)
library(lfe)
library(ggplot2)
library(knitr)
library(stargazer)

# load and examine panelist data
load("/classes/37105/main/Assignment-3/panelists.RData")
names(panelists)
```

It is important to note that household income is represented as a factor with different levels representing an income range:

```{r}
# inspect household_income variable
is.factor(panelists$household_income)
levels(panelists$household_income)
```

Our results were easier to interpret if we converted the factor representation of income to a dollar measure as follows:

```{r}
# convert household_income to dollars
panelists[household_income == "-$5000", income := 2500]
panelists[household_income == "$5000-$7999", income := 6500]
panelists[household_income == "$8000-$9999", income := 9000]
panelists[household_income == "$10,000-$11,999", income := 11000]
panelists[household_income == "$12,000-$14,999", income := 13500]
panelists[household_income == "$15,000-$19,999", income := 17500]
panelists[household_income == "$20,000-$24,999", income := 22500]
panelists[household_income == "$25,000-$29,999", income := 27500]
panelists[household_income == "$30,000-$34,999", income := 32500]
panelists[household_income == "$35,000-$39,999", income := 37500]
panelists[household_income == "$40,000-$44,999", income := 42500]
panelists[household_income == "$45,000-$49,999", income := 47500]
panelists[household_income == "$50,000-$59,999", income := 55000]
panelists[household_income == "$60,000-$69,999", income := 65000]
panelists[household_income == "$70,000-$99,999", income := 85000]
panelists[household_income == "$100,000 + ", income := 112500]
panelists[household_income == "$100,000 - $124,999", income := 112500]
panelists[household_income == "$125,000 - $149,999", income := 132500]
panelists[household_income == "$150,000 - $199,999", income := 175000]
panelists[household_income == "$200,000 + ", income := 250000]
```

Because the detailed income levels above \$100,000 were only recorded for the 2006-2009 panel years, for consistency we replaced these values with \$112,500:

```{r}
# replace high incomes with $112,500
panelists[income >= 100000, income := 112500]
```

Furthermore, Homescan's household income data represents ranges of total household income for the full year that is 2 years prior to the Panel Year. To correctly date the income data we needed to associate the income reported two years in the future with the current panel year:

```{r}
# make sure panelists table is correctly keyed
key(panelists)

# replace income for a given year with the lead of income two years ahead
panelists[, income := shift(income, n = 2, type = "lead"), by = household_code]
```

Some of the key demographic variables, in particular, age or birth year, employment, and education, are available both for a male head and a female head in each household. However, depending on the household composition, only one household head may be present, and more generally we want to simplify this information to make our results more easily interpretable.

A simple solution is to use information on employment, etc., for the male head by default, and use information for the female head if no male head is present in a household. The choice of the male head reflects that the incidence of the employment status `Not Employed for Pay` is higher for the female head than for the male
head in the data. We confirmed this:

```{r}
# incidence of employment status "Not Employed for Pay" by gender
nrow(panelists[panelists$male_head_employment == "Not Employed for Pay"])
nrow(panelists[panelists$female_head_employment == "Not Employed for Pay"])
```

Then we created new `age`, `unemployed`, and `education` variables:

```{r}
# female head flag
panelists[, female_head := male_head_age == "No Such Head"]

# age variable - converted from birth year character string
head(panelists$female_head_birth)
panelists[, age := male_head_birth]
panelists[female_head == TRUE, age := female_head_birth]
panelists[, age := panel_year - as.numeric(substr(age, 1, 4))]

# unemployed flag
panelists[, unemployed := male_head_employment == "Not Employed for Pay"]
panelists[female_head == TRUE, 
          unemployed := female_head_employment == "Not Employed for Pay"]

# education flag
panelists[, education := male_head_education]
panelists[female_head == TRUE, education := female_head_education]
```

In addition, we created two more variables. `size` provides a numeric measure of the `household_size` of a panelist. `has_children` is a dummy indicator that equals 1 if children are present in the household:

```{r}
# size variable
levels(panelists$household_size)
panelists[household_size == "Single Member", size := 1]
panelists[household_size == "Two Members", size := 2]
panelists[household_size == "Three Members", size := 3]
panelists[household_size == "Four Members", size := 4]
panelists[household_size == "Five Members", size := 5]
panelists[household_size == "Six Members", size := 6]
panelists[household_size == "Seven Members", size := 7]
panelists[household_size == "Eight Members", size := 8]
panelists[household_size == "Nine+ Members", size := 9]

# has_children variable
levels(panelists$age_and_presence_of_children)
panelists[, has_children := TRUE]
panelists[age_and_presence_of_children == "No Children Under 18"]$has_children = FALSE
```



